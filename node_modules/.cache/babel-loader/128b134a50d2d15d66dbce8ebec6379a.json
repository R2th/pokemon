{"ast":null,"code":"import _slicedToArray from\"E:/Desktop/game-pikachu-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect,useCallback}from\"react\";export var ResponseStatus;// Hook\n(function(ResponseStatus){ResponseStatus[\"SUCCESS\"]=\"success\";ResponseStatus[\"ERROR\"]=\"error\";ResponseStatus[\"IDLE\"]=\"idle\";ResponseStatus[\"PENDING\"]=\"pending\";})(ResponseStatus||(ResponseStatus={}));var useAsync=function useAsync(asyncFunction){var immediate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var _useState=useState(ResponseStatus.IDLE),_useState2=_slicedToArray(_useState,2),status=_useState2[0],setStatus=_useState2[1];var _useState3=useState(null),_useState4=_slicedToArray(_useState3,2),value=_useState4[0],setValue=_useState4[1];var _useState5=useState(null),_useState6=_slicedToArray(_useState5,2),error=_useState6[0],setError=_useState6[1];// The execute function wraps asyncFunction and\n// handles setting state for pending, value, and error.\n// useCallback ensures the below useEffect is not called\n// on every render, but only if asyncFunction changes.\nvar execute=useCallback(function(){setStatus(ResponseStatus.PENDING);setValue(null);setError(null);return asyncFunction().then(function(response){if(response){setValue(response);}setStatus(ResponseStatus.SUCCESS);}).catch(function(error){if(error){setError(error);}setStatus(ResponseStatus.ERROR);});},[asyncFunction]);// Call execute if we want to fire it right away.\n// Otherwise execute can be called later, such as\n// in an onClick handler.\nuseEffect(function(){if(immediate){execute();}},[execute,immediate]);return{execute:execute,status:status,value:value,error:error};};export default useAsync;","map":{"version":3,"sources":["E:/Desktop/game-pikachu-v2/src/hooks/useAsync.ts"],"names":["useState","useEffect","useCallback","ResponseStatus","useAsync","asyncFunction","immediate","IDLE","status","setStatus","value","setValue","error","setError","execute","PENDING","then","response","SUCCESS","catch","ERROR"],"mappings":"iJAAA,OAASA,QAAT,CAAmBC,SAAnB,CAA8BC,WAA9B,KAAiD,OAAjD,CAeA,UAAYC,CAAAA,cAAZ,CAOA;UAPYA,c,EAAAA,c,sBAAAA,c,kBAAAA,c,gBAAAA,c,yBAAAA,c,GAAAA,c,MAQZ,GAAMC,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CACfC,aADe,CAGZ,IADHC,CAAAA,SACG,2DADS,IACT,CACH,cAA4BN,QAAQ,CAAiBG,cAAc,CAACI,IAAhC,CAApC,wCAAOC,MAAP,eAAeC,SAAf,eACA,eAA0BT,QAAQ,CAAmB,IAAnB,CAAlC,yCAAOU,KAAP,eAAcC,QAAd,eACA,eAA0BX,QAAQ,CAA2B,IAA3B,CAAlC,yCAAOY,KAAP,eAAcC,QAAd,eACA;AACA;AACA;AACA;AACA,GAAMC,CAAAA,OAAO,CAAGZ,WAAW,CAAC,UAAM,CAChCO,SAAS,CAACN,cAAc,CAACY,OAAhB,CAAT,CACAJ,QAAQ,CAAC,IAAD,CAAR,CACAE,QAAQ,CAAC,IAAD,CAAR,CACA,MAAOR,CAAAA,aAAa,GACjBW,IADI,CACC,SAACC,QAAD,CAAiB,CACrB,GAAIA,QAAJ,CAAc,CACZN,QAAQ,CAACM,QAAD,CAAR,CACD,CACDR,SAAS,CAACN,cAAc,CAACe,OAAhB,CAAT,CACD,CANI,EAOJC,KAPI,CAOE,SAACP,KAAD,CAA0B,CAC/B,GAAIA,KAAJ,CAAW,CACTC,QAAQ,CAACD,KAAD,CAAR,CACD,CACDH,SAAS,CAACN,cAAc,CAACiB,KAAhB,CAAT,CACD,CAZI,CAAP,CAaD,CAjB0B,CAiBxB,CAACf,aAAD,CAjBwB,CAA3B,CAkBA;AACA;AACA;AACAJ,SAAS,CAAC,UAAM,CACd,GAAIK,SAAJ,CAAe,CACbQ,OAAO,GACR,CACF,CAJQ,CAIN,CAACA,OAAD,CAAUR,SAAV,CAJM,CAAT,CAKA,MAAO,CAAEQ,OAAO,CAAPA,OAAF,CAAWN,MAAM,CAANA,MAAX,CAAmBE,KAAK,CAALA,KAAnB,CAA0BE,KAAK,CAALA,KAA1B,CAAP,CACD,CAtCD,CAwCA,cAAeR,CAAAA,QAAf","sourcesContent":["import { useState, useEffect, useCallback } from \"react\";\r\n\r\nexport type ResponseData = Record<string, any> | null;\r\n\r\nexport interface Response {\r\n  success: boolean;\r\n  message: string;\r\n  data?: ResponseData;\r\n  error?: string;\r\n}\r\n\r\nexport interface ResponseError extends Response {\r\n  error?: string;\r\n}\r\n\r\nexport enum ResponseStatus {\r\n  SUCCESS = \"success\",\r\n  ERROR = \"error\",\r\n  IDLE = \"idle\",\r\n  PENDING = \"pending\",\r\n}\r\n\r\n// Hook\r\nconst useAsync = <T extends Response, E = string>(\r\n  asyncFunction: () => Promise<T>,\r\n  immediate = true\r\n) => {\r\n  const [status, setStatus] = useState<ResponseStatus>(ResponseStatus.IDLE);\r\n  const [value, setValue] = useState<T | ResponseData>(null);\r\n  const [error, setError] = useState<E | ResponseError | null>(null);\r\n  // The execute function wraps asyncFunction and\r\n  // handles setting state for pending, value, and error.\r\n  // useCallback ensures the below useEffect is not called\r\n  // on every render, but only if asyncFunction changes.\r\n  const execute = useCallback(() => {\r\n    setStatus(ResponseStatus.PENDING);\r\n    setValue(null);\r\n    setError(null);\r\n    return asyncFunction()\r\n      .then((response: T) => {\r\n        if (response) {\r\n          setValue(response);\r\n        }\r\n        setStatus(ResponseStatus.SUCCESS);\r\n      })\r\n      .catch((error: ResponseError) => {\r\n        if (error) {\r\n          setError(error);\r\n        }\r\n        setStatus(ResponseStatus.ERROR);\r\n      });\r\n  }, [asyncFunction]);\r\n  // Call execute if we want to fire it right away.\r\n  // Otherwise execute can be called later, such as\r\n  // in an onClick handler.\r\n  useEffect(() => {\r\n    if (immediate) {\r\n      execute();\r\n    }\r\n  }, [execute, immediate]);\r\n  return { execute, status, value, error };\r\n};\r\n\r\nexport default useAsync;\r\n"]},"metadata":{},"sourceType":"module"}